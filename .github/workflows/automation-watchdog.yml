name: Automation Watchdog

on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:

permissions:
  contents: read
  actions: write
  issues: write

concurrency:
  group: automation-watchdog
  cancel-in-progress: false

jobs:
  watchdog:
    runs-on: ubuntu-latest
    env:
      PM_CYCLE_ISSUE_NUMBER: ${{ vars.PM_CYCLE_ISSUE_NUMBER }}
      PM_MAX_IDLE_MINUTES: ${{ vars.PM_MAX_IDLE_MINUTES }}
      INGEST_MAX_IDLE_MINUTES: ${{ vars.INGEST_MAX_IDLE_MINUTES }}
    steps:
      - name: Self-heal workflow idle gaps
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const now = new Date();

            const pmIdleMax = Number.parseInt(process.env.PM_MAX_IDLE_MINUTES || '70', 10);
            const ingestIdleMax = Number.parseInt(process.env.INGEST_MAX_IDLE_MINUTES || '150', 10);
            const pmIssueNumber = Number.parseInt(process.env.PM_CYCLE_ISSUE_NUMBER || '', 10);

            async function getWorkflowByName(name) {
              const workflows = await github.paginate(github.rest.actions.listRepoWorkflows, {
                owner,
                repo,
                per_page: 100,
              });
              return workflows.find((w) => w.name === name) || null;
            }

            async function latestRunAgeMinutes(workflowId) {
              const runs = await github.request('GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs', {
                owner,
                repo,
                workflow_id: workflowId,
                per_page: 1,
              });
              if (!runs.data.workflow_runs || runs.data.workflow_runs.length === 0) return Number.POSITIVE_INFINITY;
              const createdAt = new Date(runs.data.workflow_runs[0].created_at);
              return Math.floor((now - createdAt) / 60000);
            }

            async function maybeDispatch(workflowName, maxIdle, reasonTag) {
              const wf = await getWorkflowByName(workflowName);
              if (!wf) {
                return { workflowName, dispatched: false, reason: 'workflow_not_found' };
              }
              const age = await latestRunAgeMinutes(wf.id);
              if (age <= maxIdle) {
                return { workflowName, dispatched: false, reason: `healthy(age=${age}m<=${maxIdle}m)` };
              }

              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: wf.id,
                ref: context.ref.replace('refs/heads/', ''),
              });

              return { workflowName, dispatched: true, reason: `${reasonTag}(age=${age}m>${maxIdle}m)` };
            }

            const pmResult = await maybeDispatch('PM Cycle', pmIdleMax, 'pm_idle_self_heal');
            const ingestResult = await maybeDispatch('Ingest Schedule', ingestIdleMax, 'ingest_idle_self_heal');

            const lines = [
              '[PM AUTO][WATCHDOG]',
              `auto_key: watchdog-${context.runId}`,
              `decision: PM=${pmResult.dispatched ? 'dispatch' : 'skip'}; INGEST=${ingestResult.dispatched ? 'dispatch' : 'skip'}`,
              'next_status: status/in-progress',
              `evidence: PM(${pmResult.reason}); INGEST(${ingestResult.reason})`,
            ];

            if (Number.isFinite(pmIssueNumber) && pmIssueNumber > 0 && (pmResult.dispatched || ingestResult.dispatched)) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pmIssueNumber,
                body: lines.join('\n'),
              });
            }

            await core.summary
              .addHeading('Automation Watchdog Result')
              .addRaw(`PM Cycle: ${pmResult.dispatched ? 'dispatch' : 'skip'} (${pmResult.reason})\n`)
              .addRaw(`Ingest Schedule: ${ingestResult.dispatched ? 'dispatch' : 'skip'} (${ingestResult.reason})\n`)
              .write();
